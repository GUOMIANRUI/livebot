package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"ks/global"
	"ks/ksgift"
	"log"
	"net/http"
	"os"
	"time"

	"github.com/gorilla/websocket"
)

var ksgiftdata *ksgift.AutoGenerated

func main() {
	// go func() {
	// 	lunbo.Lunbo("大象灵魂的黑夜")
	// }()

	// 获取快手礼物数据，保存到json文件，如果文件存在就先读取文件，每天刷新一次
	filename := "ksgifts.json"
	_, err := os.Stat(filename)

	if err == nil {
		// 文件存在，先读取文件中的数据
		ksgiftdata, err = readDataFromFile(filename)
		if err != nil {
			fmt.Println("读取文件失败:", err)
			return
		}
	} else {
		// 文件不存在，获取数据并保存到文件
		ksgiftdata, err := ksgift.Ksgift()
		if err != nil {
			fmt.Println("获取数据失败:", err)
			return
		}
		saveDataToFile(ksgiftdata, filename)

	}

	// 设置 WebSocket 路由
	http.HandleFunc("/ws", wsHandler)

	// 启动服务器
	log.Println("服务器已启动，监听端口 8080...")
	err = http.ListenAndServe(":8080", nil)
	if err != nil {
		log.Fatal("服务器启动失败:", err)
	}

	// 每天刷新一次数据
	ticker := time.NewTicker(24 * time.Hour)
	for range ticker.C {
		ksgiftdata, err := ksgift.Ksgift()
		if err != nil {
			fmt.Println("获取数据失败:", err)
			return
		}
		saveDataToFile(ksgiftdata, filename)
	}
}

// 处理 WebSocket 连接
func wsHandler(w http.ResponseWriter, r *http.Request) {
	// 升级 HTTP 连接为 WebSocket
	conn, err := websocket.Upgrade(w, r, nil, 1024, 1024)
	if err != nil {
		log.Println(err)
		return
	}
	defer conn.Close()

	// 读取 JSON 数据
	_, msg, err := conn.ReadMessage()
	if err != nil {
		log.Println("读取消息时发生错误:", err)
		return
	}

	// 解析 JSON 数据 当数据未知时直接打印出来
	// var data map[string]interface{}
	// err = json.Unmarshal(msg, &data)
	// if err != nil {
	// 	log.Println("解析 JSON 数据时发生错误:", err)
	// 	return
	// }
	// // 处理收到的数据
	// fmt.Printf("收到来自 Python 的消息: %+v\n", data)

	data := &global.Message{}
	err = json.Unmarshal(msg, &data)
	if err != nil {
		log.Println("解析 JSON 数据时发生错误:", err)
		return
	}

	// 实时增量保存 data 数据到 json 文件
	err = SaveToFile(data, "message.json")
	if err != nil {
		log.Println("保存数据到文件时发生错误：", err)
	} else {
		log.Println("数据已成功保存到文件")
	}
	// 读取文件中的数据
	messagetmp, err := ReadFromFile("message.json")
	if err != nil {
		log.Println("读取文件时发生错误：", err)
	}
	messagetmp.DisplayLikeCount = data.DisplayLikeCount
	messagetmp.DisplayWatchingCount = data.DisplayWatchingCount
	messagetmp.GiftFeeds = append(messagetmp.GiftFeeds, data.GiftFeeds...)
	messagetmp.CommentFeeds = append(messagetmp.CommentFeeds, data.CommentFeeds...)
	messagetmp.LikeFeeds = append(messagetmp.LikeFeeds, data.LikeFeeds...)

	err = SaveToFile(messagetmp, "message.json")
	if err != nil {
		log.Println("保存数据到文件时发生错误：", err)
	} else {
		log.Println("数据已成功保存到文件")
	}

	global.SetMessage(*data)

	if data.CommentFeeds != nil {
		for _, m := range data.CommentFeeds {
			fmt.Printf("[📧直播间弹幕消息][%v]说:%v\n", m.User.UserName, m.Content)
		}
	}
	if data.GiftFeeds != nil {
		for _, m := range data.GiftFeeds {
			giftname := ksgiftdata.Data[fmt.Sprintf("%v", m.GiftID)].GiftName
			if giftname == "" {
				giftname = "未知礼物"
			}
			fmt.Printf("[🎁直播间礼物消息]%v赠送礼物Id=%v 连击数=%v\n", m.User.UserName, giftname, m.ComboCount)
		}
	}
	if data.LikeFeeds != nil {
		for _, m := range data.LikeFeeds {
			fmt.Printf("%v点赞了\n", m.User.UserName)
		}
	}
	if data.DisplayLikeCount != "" {
		fmt.Printf("总共有 %v 个点赞\n", data.DisplayLikeCount)
	}
	if data.DisplayWatchingCount != "" {
		fmt.Printf("总共有 %v 个观看\n", data.DisplayWatchingCount)
	}
}

func saveDataToFile(data *ksgift.AutoGenerated, filename string) error {
	// 将数据转换为JSON格式
	jsonData, err := json.Marshal(data)
	if err != nil {
		return err
	}

	// 写入文件
	err = ioutil.WriteFile(filename, jsonData, 0644)
	if err != nil {
		return err
	}

	fmt.Println("数据已保存到文件:", filename)
	return nil
}

func readDataFromFile(filename string) (*ksgift.AutoGenerated, error) {
	// 读取文件内容
	fileData, err := ioutil.ReadFile(filename)
	if err != nil {
		return nil, err
	}

	// 解析JSON数据
	var data ksgift.AutoGenerated
	err = json.Unmarshal(fileData, &data)
	if err != nil {
		return nil, err
	}

	return &data, nil
}

func ReadFromFile(filename string) (*global.Message, error) {
	// 从文件中读取数据
	content, err := ioutil.ReadFile(filename)
	if err != nil {
		return nil, err
	}

	// 解析 JSON 数据
	data := &global.Message{}
	err = json.Unmarshal(content, &data)
	if err != nil {
		return nil, err
	}

	return data, nil
}

func SaveToFile(data *global.Message, filename string) error {
	// 将数据序列化为JSON字符串
	jsonData, err := json.MarshalIndent(data, "", "  ")
	if err != nil {
		return err
	}

	// 保存JSON数据到文件
	err = ioutil.WriteFile(filename, jsonData, 0644)
	if err != nil {
		return err
	}

	return nil
}
