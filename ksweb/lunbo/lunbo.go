package main

import (
	"bufio"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"ks/global"
	"ks/ksgift"
	pb "ks/stub/gochat/proto"
	"log"
	"os"
	"strconv"
	"strings"
	"time"

	"github.com/gdamore/tcell/v2"
	"github.com/rivo/tview"
	"trpc.group/trpc-go/trpc-go"
	"trpc.group/trpc-go/trpc-go/client"
)

var (
	DefaultSlideDuration = 1 * time.Second     // 默认每则故事的轮播时间间隔
	ksgiftdata           *ksgift.AutoGenerated // 快手礼物列表
)

type Story struct {
	Title   string
	Content []string
}

func main() {
	Lunbo("人生的第二志愿")
}

func Lunbo(startTitle string) {
	stories, err := readStoriesFromFile("gushi.txt")
	if err != nil {
		fmt.Println("读取故事文件失败:", err)
		return
	}

	app := tview.NewApplication()

	titleTextView := tview.NewTextView().
		SetDynamicColors(false).
		SetTextAlign(tview.AlignCenter).
		SetTextColor(tcell.ColorYellow)

	contentTextView := tview.NewTextView().
		SetDynamicColors(false).
		SetTextAlign(tview.AlignCenter).
		SetTextColor(tcell.ColorWhite)

	flex := tview.NewFlex().
		SetDirection(tview.FlexRow).
		AddItem(titleTextView, 1, 1, false).
		AddItem(contentTextView, 0, 1, false)

	pages := tview.NewPages().
		AddPage("page", flex, true, true)

	app.SetRoot(pages, true)

	// trpc client
	proxy := pb.NewGoChatServiceClientProxy(
		client.WithTarget("ip://127.0.0.1:8000"),
		client.WithProtocol("trpc"),
	)
	ctx := trpc.BackgroundContext()
	var voicefilename string
	var welcomemsg string

	go func() {
		startIndex := 0
		// 查找指定标题在故事列表中的索引
		for i, story := range stories {
			if story.Title == startTitle {
				startIndex = i
				break
			}
		}
		pp := 0
		ksgiftdata, err = readDataFromFile("../ksgifts.json")
		if err != nil {
			fmt.Println("读取文件失败:", err)
			return
		}

		for p0 := startIndex; p0 < len(stories); p0++ {
			story := stories[p0]
			for p, line := range story.Content {
				app.QueueUpdateDraw(func() {
					titleTextView.SetText(story.Title)
					contentTextView.SetText(strings.TrimSpace(line))
				})
				var longmsg int32
				longmsg = 0
				// 如果是指定标题的第1行，则把标题转语音
				if p == 0 {
					req := &pb.GoChataudioRequest{}
					voicefilename = strconv.Itoa(p0) + "-" + strconv.Itoa(p) + "title" + ".mp3"
					req.Filename = voicefilename
					req.Msg = story.Title
				retryaudiot:
					reply, err := proxy.GoChatAudio(ctx, req)
					if err != nil {
						if pp <= 4 {
							pp++
							goto retryaudiot
						}
						log.Fatalf("err: %v", err)
					}
					longmsg = reply.Filelongth
					longmsg += reply.Filelongth + 1 // 留1秒缓冲
					time.Sleep(time.Duration(longmsg) * time.Second)
					longmsg = 0
				}

				// 把内容也转语音
				req := &pb.GoChataudioRequest{}
				voicefilename = strconv.Itoa(p0) + "-" + strconv.Itoa(p) + "content" + ".mp3"
				req.Filename = voicefilename
				req.Msg = strings.TrimSpace(line)
			retryaudiot2:
				reply, err := proxy.GoChatAudio(ctx, req)
				if err != nil {
					if pp <= 4 {
						pp++
						goto retryaudiot2
					}
					log.Fatalf("err: %v", err)
				}
				longmsg += reply.Filelongth + 1 // 留1秒缓冲
				if longmsg > 0 {
					time.Sleep(getSlideDuration(longmsg)) // 轮播时间间隔
				}

			}
			// 读完一段故事，欢迎新进入直播间的观众
			welcomemsg = "欢迎新进入直播间的同学们"
			req := &pb.GoChataudioRequest{}
			voicefilename = "welcome" + ".mp3"
			req.Filename = voicefilename
			req.Msg = welcomemsg
			reply, err := proxy.GoChatAudio(ctx, req)
			if err != nil {
				log.Fatalf("err: %v", err)
			}
			longmsg := reply.Filelongth
			longmsg += reply.Filelongth + 1 // 留1秒缓冲
			time.Sleep(time.Duration(longmsg) * time.Second)
			// 读取进入直播间的观众的列表 spectators 选前4个读取欢迎词
			// message := global.GetMessage()
			// 读取文件中的数据
			message, err := readFromFile("../message.json")
			if err != nil {
				log.Println("读取文件时发生错误：", err)
			}

			// log.Println(message)
			usermsg := message.CommentFeeds
			var weluser string
			// 做下去重
			onlyuser := make(map[string]bool)

			if len(usermsg) > 0 {
				for i, v := range usermsg {
					if _, ok := onlyuser[v.User.UserName]; !ok && i <= 5 {
						onlyuser[v.User.UserName] = true
						weluser = weluser + v.User.UserName + "、"
					}
				}
			} else {
				goto welpass
			}

			weluser = "欢迎" + weluser + "  进入直播间"
			req.Msg = weluser
			req.Filename = "weluser" + strconv.Itoa(p0) + "name" + ".mp3"
			reply, err = proxy.GoChatAudio(ctx, req)
			if err != nil {
				log.Fatalf("err: %v", err)
			}
			longmsg = reply.Filelongth
			longmsg += reply.Filelongth + 1 // 留1秒缓冲
			time.Sleep(time.Duration(longmsg) * time.Second)
		welpass:

			// 如果有人点赞，选前4个感谢点赞
			var likemsg string
			likeuser := message.LikeFeeds
			if len(likeuser) > 0 {
				for i, v := range likeuser {
					if i <= 4 {
						likemsg = likemsg + v.User.UserName + "、"
					}
				}
			} else {
				goto thklikepass
			}
			likemsg = "感谢" + likemsg + "的点赞"
			req.Msg = likemsg
			req.Filename = "thklike" + strconv.Itoa(p0) + "name" + ".mp3"
			reply, err = proxy.GoChatAudio(ctx, req)
			if err != nil {
				log.Fatalf("err: %v", err)
			}
			longmsg = reply.Filelongth
			longmsg += reply.Filelongth + 1 // 留1秒缓冲
			time.Sleep(time.Duration(longmsg) * time.Second)
		thklikepass:

			// 读取前四位送的礼物并感谢
			var giftmsg string
			giftuser := message.GiftFeeds
			if len(message.GiftFeeds) > 0 {
				// log.Printf("message.GiftFeeds=%v\n", message.GiftFeeds)
				for i, v := range giftuser {
					if i <= 4 {
						giftname := ksgiftdata.Data[fmt.Sprintf("%v", v.GiftID)].GiftName
						if giftname == "" {
							giftname = "未知礼物"
						}
						if i != 4 {
							giftmsg = giftmsg + v.User.UserName + "送的" + giftname + "、感谢"
						} else {
							giftmsg = giftmsg + v.User.UserName + "送的" + giftname
						}
					}
				}
			} else {
				goto thkgiftpass
			}
			giftmsg = "感谢" + giftmsg
			req.Msg = giftmsg
			req.Filename = "thkgift" + strconv.Itoa(p0) + "name" + ".mp3"
			reply, err = proxy.GoChatAudio(ctx, req)
			if err != nil {
				log.Fatalf("err: %v", err)
			}
			longmsg = reply.Filelongth
			longmsg += reply.Filelongth + 1 // 留1秒缓冲
			time.Sleep(time.Duration(longmsg) * time.Second)
		thkgiftpass:

			// 读取进入直播间的观众的问题列表 questions 选长度大于5的前1个进行回答
			for _, v := range message.CommentFeeds {
				if len(v.Content) > 5 && strings.Contains(v.Content, "赞了这个直播") == false {
					reqtxt := &pb.GoChatRequest{}
					reqtxt.Msg = "你是一位文学杂志作者，请简要回答观众的问题，控制在100字以内：" + v.Content
					replytxt, err := proxy.GoChat(ctx, reqtxt)
					if err != nil {
						log.Fatalf("err: %v", err)
					}

					req.Filename = "answer" + strconv.Itoa(p0) + "content" + ".mp3"
					req.Msg = v.User.UserName + "说" + v.Content + "，我想说的是：" + replytxt.Msg
					reply, err = proxy.GoChatAudio(ctx, req)
					if err != nil {
						log.Fatalf("err: %v", err)
					}
					longmsg = reply.Filelongth
					longmsg += reply.Filelongth + 1 // 留1秒缓冲
					time.Sleep(time.Duration(longmsg) * time.Second)
					break
				}
			}

			// 好的，让我们开始下一段故事
			req.Msg = "好的，让我们开始下一段故事"
			req.Filename = "end" + ".mp3"
			reply, err = proxy.GoChatAudio(ctx, req)
			if err != nil {
				log.Fatalf("err: %v", err)
			}
			longmsg = reply.Filelongth
			longmsg += reply.Filelongth + 1 // 留1秒缓冲
			time.Sleep(time.Duration(longmsg) * time.Second)

			// 清空json文件
			data := &global.Message{}
			err = SaveToFile(data, "../message.json")
			if err != nil {
				log.Println("覆盖文件时发生错误：", err)
			} else {
				// log.Println("文件已成功覆盖")
			}
		}
	}()

	if err := app.Run(); err != nil {
		fmt.Println("运行应用程序时发生错误:", err)
	}
}

func readStoriesFromFile(filename string) ([]Story, error) {
	var stories []Story

	file, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	var currentStory Story
	isContentLine := false

	for scanner.Scan() {
		line := scanner.Text()

		if strings.HasPrefix(line, " ") {
			// 如果行以空格开头，则为内容行
			if isContentLine {
				// 如果是内容行，则将内容添加到当前故事的 Content 字段中
				currentStory.Content = append(currentStory.Content, line)
			}
		} else {
			// 如果行不以空格开头，则为标题行
			if currentStory.Title != "" {
				// 如果当前故事的标题不为空，则将当前故事添加到故事列表中
				stories = append(stories, currentStory)
			}

			// 创建新的故事，将标题行作为新故事的标题
			currentStory = Story{
				Title:   line,
				Content: []string{},
			}
			isContentLine = true
		}
	}

	if currentStory.Title != "" {
		// 将最后一个故事添加到故事列表中
		stories = append(stories, currentStory)
	}

	if err := scanner.Err(); err != nil {
		return nil, err
	}

	return stories, nil
}

func getSlideDuration(longmsg int32) time.Duration {
	// 在此函数中根据需求计算并返回每次轮播的时间间隔
	// 这里使用默认的时间间隔作为示例
	DefaultSlideDuration = time.Duration(longmsg) * time.Second
	return DefaultSlideDuration
}

func readFromFile(filename string) (*global.Message, error) {
	// 从文件中读取数据
	content, err := ioutil.ReadFile(filename)
	if err != nil {
		return nil, err
	}

	// 解析 JSON 数据
	data := &global.Message{}
	err = json.Unmarshal(content, &data)
	if err != nil {
		return nil, err
	}

	return data, nil
}

func readDataFromFile(filename string) (*ksgift.AutoGenerated, error) {
	// 从文件中读取数据
	content, err := ioutil.ReadFile(filename)
	if err != nil {
		return nil, err
	}

	// 解析 JSON 数据
	data := &ksgift.AutoGenerated{}
	err = json.Unmarshal(content, &data)
	if err != nil {
		return nil, err
	}

	return data, nil
}

func SaveToFile(data *global.Message, filename string) error {
	// 将数据序列化为JSON字符串
	jsonData, err := json.MarshalIndent(data, "", "  ")
	if err != nil {
		return err
	}

	// 保存JSON数据到文件
	err = ioutil.WriteFile(filename, jsonData, 0644)
	if err != nil {
		return err
	}

	return nil
}
